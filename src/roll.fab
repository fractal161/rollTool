charmap("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ·.-*%⊏⊐⊑⊒[]_⎺")
// []

vars /record_state
    Bool recording = false
    U grace = 0

vars /hz
    U [64] poll_buffer
    U poll_buffer_index = 0
    U poll_tile_index = 0
    Bool last_poll_on = false

data /backgrounds
    [] bg
        ("································"
         "································"
         "···00.00*·······················"
         "································"
         "···0·TAPS·······················"
         "································"
         "·______________________________·"
         "[⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐]"
         "·⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺·"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································")

fn load_bg()
    // Tell the NES which VRAM address we want to upload to:
    ppu_reset_addr($2000)

    // Upload the tile data:
    for UU i = 0; i < 960; i += 1
        {PPUDATA}(@bg{i})

    // Then the attributes:
    for U i = 0; i < 64; i += 1
        {PPUDATA}(%00000000)

    // do it all again for second nametable

fn prepare_sprites()
    U oam_index = 0
    if recording
        set_oam(oam_index, 4, 4, RECORD_SPRITE, %11)
        oam_index += 4
    // write hz sprites
    // write tap count sprite
    // write probability sprites
    hide_oam(oam_index)

fn clear_poll_vars()
    for U i = 0; i < 32; i += 1
        poll_buffer[i] = 0
    poll_buffer_index = 0
    poll_tile_index = 0
    last_poll_on = false


irq subframe_poll()
    // immediately schedule next irq
    // waste cycles for more accuracy??
    // poll controller
    // if L/R, update active buffer with next tile

nmi main_nmi()
    // Update OAM and poll the pads: (TODO: measure timing)
    ppu_upload_oam_poll_pads(0)
    if recording
        poll_buffer_index += 2 // a frame is two tiles wide
        poll_tile_index = 0

        // update poll tiles if needed (2 tiles)
        // update frame row if needed (2 tiles, maybe 4)
        // update probability buffers (45 tiles???)

    // set scroll to show current roll viz row
    ppu_reset_scroll(0, 0)

mode main()
: nmi main_nmi
    // Set the palette:
    palette = START_PALETTE
    ppu_upload_palette()

    // Set and load the level:
    hide_oam(0)
    load_bg()
    clear_poll_vars()

    // enable nmi, turn on rendering
    {PPUCTRL}(PPUCTRL_NMI_ON)
    {PPUMASK}(PPUMASK_ON | PPUMASK_NO_CLIP)

    // Wait forever, one frame at a time:
    while true
        update_pads()
        Bool is_button_pressed = pads[0].held
        if recording
            // eventually this part will go in the irq
            if is_button_pressed
                U i = poll_buffer_index
                poll_buffer[i] = 1
                poll_buffer[i+1] = 1
                grace = GRACE_PERIOD
            if grace == 0
                recording = false
                clear_poll_vars()
            else
                grace -= 1
        // starts recording, manually set start of buffer
        else if is_button_pressed
            recording = true
            poll_buffer[0] = 1
            poll_buffer[1] = 1
            grace = GRACE_PERIOD
            
        // SUBFRAME LOOP
        // all computations here are done with the previous frame's inputs
        // i.e. only what's been completely finalized

        // if x frames since last input, set recording = false
        // clear buffers as needed

        // otherwise, recording = true
        // update hz measurement(s)
        // update tap count
        // update probability buffers???

        prepare_sprites()
        nmi

chrrom
    file(fmt, "../chr/hud.png")
    file(fmt, "../chr/hud.png")
