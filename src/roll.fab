charmap("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ·.-*%⊏⊐⊑⊒[]_⎺")
// []

vars /record_state
    Bool recording = false
    U grace = 0

vars /hz
    U [64] poll_buffer
    U poll_buffer_index = 0
    U poll_tile_index = 0
    Bool last_poll_on = false

data /backgrounds
    [] nt0
        ("································"
         "································"
         "···00.00*·······················"
         "································"
         "···0·TAPS·······················"
         "································"
         "·______________________________·"
         "[⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐]"
         "·⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺·"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································")

fn load_bg()
    // Tell the NES which VRAM address we want to upload to:
    ppu_reset_addr($2000)

    // tiles for first nametable
    for UU i = 0; i < 960; i += 1
        {PPUDATA}(@nt0{i})

    // attributes for first nametable
    for U i = 0; i < 64; i += 1
        {PPUDATA}(%00000000)

    // tiles for second nametable
    //for UU i = 0; i < 960; i += 1
    //    {PPUDATA}("SPACE TOKEN")

    // attributes for second nametable
    for U i = 0; i < 64; i += 1
        {PPUDATA}(%00000000)

fn prepare_sprites()
    U oam_index = 0
    if recording
        set_oam(oam_index, 4, 4, RECORD_SPRITE, %11)
        oam_index += 4
    // write hz sprites
    // write tap count sprite
    // write probability sprites
    hide_oam(oam_index)

fn clear_poll_vars()
    for U i = 0; i < 32; i += 1
        poll_buffer[i] = 0
    poll_buffer_index = 0
    poll_tile_index = 0
    last_poll_on = false


// this is kinda slow because of bank switches! TODO: optimize out somehow
// for scroll, hopefully does not matter
irq subframe_poll()
: +static
    // acknowledge pending irq, then immediately schedule next irq (but not now)
    {MMC3_IRQ_DISABLE}(0)
    ppu_set_mid_scroll(0, 7, 1)

    // STUFF FOR LATER
    // waste cycles for more accuracy??
    // poll controller
    // if L/R, update active buffer with next tile

nmi main_nmi()
    // Update OAM and poll the pads: (TODO: measure timing)
    ppu_upload_oam_poll_pads(0)
    // schedule irq for showing nt1
    mmc3_timer(72)
    if recording
        if poll_buffer_index < POLL_BUFFER_SIZE
            poll_buffer_index += 2 // a frame is two tiles wide
            poll_tile_index = 0

        // update poll tiles if needed (2 tiles)
        // update frame row if needed (2 tiles, maybe 4)
        // update probability buffers (45 tiles???)

    // set scroll to show current roll viz row
    ppu_reset_mid_scroll(0, 0, 0)

mode main()
: nmi main_nmi
: irq subframe_poll
    // set the palette:
    palette = START_PALETTE
    ppu_upload_palette()

    // set and load the level:
    hide_oam(0)
    load_bg()
    clear_poll_vars()

    // swap sprite banks (necessary for scanline counter to work)

    // enable nmi, turn on rendering
    {PPUCTRL}(PPUCTRL_NMI_ON | PPUCTRL_SPR_PT_1000)
    {PPUMASK}(PPUMASK_ON | PPUMASK_NO_CLIP)

    // enable irqs
    irq true

    // Wait forever, one frame at a time:
    while true
        update_pads()
        Bool is_button_pressed = pads[0].held
        if recording
            // eventually this part will go in the irq
            if is_button_pressed
                U i = poll_buffer_index
                if i < POLL_BUFFER_SIZE
                    poll_buffer[i] = $FF
                    poll_buffer[i+1] = $FF
                grace = GRACE_PERIOD
            if grace == 0
                recording = false
                clear_poll_vars()
            else
                grace -= 1
        // starts recording, manually set start of buffer
        else if is_button_pressed
            recording = true
            poll_buffer[0] = $FF
            poll_buffer[1] = $FF
            grace = GRACE_PERIOD
            
        // SUBFRAME LOOP
        // all computations here are done with the previous frame's inputs
        // i.e. only what's been completely finalized

        // if x frames since last input, set recording = false
        // clear buffers as needed

        // otherwise, recording = true
        // update hz measurement(s)
        // update tap count
        // update probability buffers???

        prepare_sprites()
        nmi

chrrom
    file(fmt, "../chr/hud.png")
    file(fmt, "../chr/hud.png")
