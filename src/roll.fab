charmap("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ·.-*%⊏⊐⊑⊒[]_⎺")

vars /record_state
    Bool recording = false
    U cooldown = 0

vars /ppu
    UU roll_viz_addr = $2460
    U roll_viz_y = $12

vars /hz
    U [POLL_BUFFER_SIZE] poll_buffer
    UU poll_buffer_index = 0 // so we can track speed well beyond the screen
    U poll_index = 0
    Bool last_poll_on = false
    Bool clear_offscreen = false
    U tap_count = 0
    UU last_start_index = 0
    U[4] hz_digits = U[4](0, 0, 0, 0)

data /backgrounds
    [] nt0
        ("································"
         "·····.··*·······················"
         "································"
         "·····TAPS·······················"
         "································"
         "·····FRAMES·····················"
         "·______________________________·"
         "[⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐]"
         "·⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺·"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································")

fn load_bg()
    // Tell the NES which VRAM address we want to upload to:
    ppu_reset_addr($2000)

    // tiles for first nametable
    for UU i = 0; i < 960; i += 1
        {PPUDATA}(@nt0{i})

    // attributes for first nametable
    for U i = 0; i < 64; i += 1
        {PPUDATA}(%00000000)

    // tiles for second nametable
    for UU i = 0; i < 960; i += 1
        {PPUDATA}('·')

    // attributes for second nametable
    for U i = 0; i < 64; i += 1
        {PPUDATA}(%00000000)

fn prepare_sprites()
    U oam_index = 0
    if recording
        set_oam(oam_index, 4, 3, RECORD_SPRITE, %11)
        oam_index += 4
    // write hz sprites
    set_oam(oam_index, 24, 7, hz_digits[3], %00)
    oam_index += 4
    set_oam(oam_index, 32, 7, hz_digits[2], %00)
    oam_index += 4
    set_oam(oam_index, 48, 7, hz_digits[1], %00)
    oam_index += 4
    set_oam(oam_index, 56, 7, hz_digits[0], %00)
    oam_index += 4
    // write tap count sprite
    set_oam(oam_index, 24, 23, tap_count, %11)
    oam_index += 4
    // TEMP: write frame count
    U[2] frame_count = U[2](uu_to_ddddd(last_start_index + 1))
    set_oam(oam_index, 16, 39, frame_count[1], %11)
    oam_index += 4
    set_oam(oam_index, 24, 39, frame_count[0], %11)
    oam_index += 4
    // write probability sprites
    hide_oam(oam_index)

// be careful!! this will probably be called before the last irq, so
// don't mutate state
fn clear_vars_after_cooldown()
    for U i = 0; i < POLL_BUFFER_SIZE; i += 1
        poll_buffer[i] = '·'
    poll_buffer_index = 0

// this is kinda slow because of bank switches! TODO: optimize out somehow
// for scroll, hopefully does not matter
irq subframe_poll()
    // acknowledge pending irq, then immediately schedule next irq (but not now)
    // already disables so this is safe
    mmc3_timer(@scanline_intervals[poll_index])
    if poll_index == 5
        ppu_set_mid_scroll(0, roll_viz_y, 1)
    poll_index += 1

    // STUFF FOR LATER
    // set scroll at specific index
    // waste cycles for more accuracy??
    // poll controller
    // if L/R, update active buffer with next tile

nmi main_nmi()
    // Update OAM and poll the pads (currently scanline 246, cycle 90)
    ppu_upload_oam_poll_pads(0)
    update_pads()
    // schedule irq for showing nt1
    mmc3_timer(@scanline_intervals[0])
    poll_index = 1
    if recording
        if poll_buffer_index < UU(POLL_BUFFER_SIZE)
            // update poll tiles (2 tiles)
            U i = poll_buffer_index.a
            // update frame row if needed (2 tiles, maybe 4)
            UU poll_addr = roll_viz_addr + UU(1 + i)
            if i >= 30
                poll_addr += 2
            ppu_reset_addr(poll_addr)
            {PPUDATA}(poll_buffer[i])
            {PPUDATA}(poll_buffer[i+1])
            
            // update probability buffers (45 tiles???)

        poll_buffer_index += 2 // a frame is two tiles wide
    else if clear_offscreen
        // clear all in the topmost invisible buffer
        UU clear_addr = roll_viz_addr + $2A0
        if clear_addr >= $27C0
            clear_addr -= $3C0
        fence
        ppu_reset_addr(clear_addr)
        for U i = 0; i < 64; i += 1
            {PPUDATA}('·')
        fence
        clear_offscreen = false
    // set scroll to show current roll viz row
    ppu_reset_mid_scroll(0, 0, 0)

mode main()
: nmi main_nmi
: irq subframe_poll
    // set the palette:
    palette = START_PALETTE
    ppu_upload_palette()

    // set and load the level:
    hide_oam(0)
    load_bg()
    clear_vars_after_cooldown()

    // swap sprite banks (necessary for scanline counter to work)

    // enable nmi, turn on rendering
    {PPUCTRL}(PPUCTRL_NMI_ON | PPUCTRL_SPR_PT_1000)
    {PPUMASK}(PPUMASK_ON | PPUMASK_NO_CLIP)

    // enable irqs
    irq true

    // Wait forever, one frame at a time:
    while true
        Bool is_button_pressed = pads[0].held
        if recording
            // eventually this part will go in the irq
            if is_button_pressed
                U i = poll_buffer_index.a
                if poll_buffer_index < UU(POLL_BUFFER_SIZE)
                    poll_buffer[i] = $FF
                    poll_buffer[i+1] = $FF
                cooldown = COOLDOWN_THRESHOLD
                if !last_poll_on
                    // update hz measurement
                    tap_count += 1
                    last_start_index = poll_buffer_index >> 1
                    if tap_count > 0 && tap_count != $FF
                        UUU hz_dividend = NTSC_FRAMERATE * (tap_count - 1)
                        UUU hz = udiv_24(hz_dividend, last_start_index)
                        // TODO: this can probably go above 100
                        hz_digits = U[4](uu_to_ddddd(UU(hz)))
            else
                U i = poll_buffer_index.a
                if poll_buffer_index < UU(POLL_BUFFER_SIZE)
                    poll_buffer[i] = '·'
                    poll_buffer[i+1] = '·'
            if cooldown == 0
                recording = false
                clear_vars_after_cooldown()
                clear_offscreen = true
            else
                cooldown -= 1
            last_poll_on = is_button_pressed
        // starts recording, manually set start of buffer
        else if is_button_pressed
            recording = true
            tap_count = 1
            poll_buffer[0] = $FF
            poll_buffer[1] = $FF
            cooldown = COOLDOWN_THRESHOLD
            last_poll_on = true
            last_start_index = 0
            // scroll up to push existing entries down
            roll_viz_addr -= $60
            if roll_viz_addr < $2400
                roll_viz_addr += $3C0
            if roll_viz_y < $18
                roll_viz_y += $D8 // mod 240
            else
                roll_viz_y -= $18
            
        // SUBFRAME LOOP
        // all computations here are done with the previous frame's inputs
        // i.e. only what's been completely finalized

        // if x frames since last input, set recording = false
        // clear buffers as needed

        // otherwise, recording = true
        // update hz measurement(s)
        // update tap count
        // update probability buffers???

        prepare_sprites()
        nmi

chrrom
    file(fmt, "../chr/hud.png")
    file(fmt, "../chr/hud.png")
    file(fmt, "../chr/hz.png")
