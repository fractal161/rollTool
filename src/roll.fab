charmap("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ·.-*%⊏⊐⊑⊒[]_⎺")

vars /stats
    U stat_mode = 0

vars /record_state
    Bool recording = false
    Bool last_recording = false
    U cooldown = 0

vars /ppu
    UU roll_viz_addr = $2460
    U roll_viz_y = $14
    U main_hz_color = $00
    U waste_time = $00

vars /hz
    U[2] polls_this_frame = U[2](0, 0)
    UU num_frames_recording = 0
    UU hz = 0
    U subframe_index = 0
    Bool prev_poll_on = false
    Bool prev_nmi_poll_on = false
    Bool clear_offscreen = false

    U tap_count = 0
    UU start_index = 0
    UU end_index = 0

    U last_tap_count = 0
    UU last_end_index = 0

    U[5] hz_digits = U[5](0, 0, 0, 0, 0)

data /backgrounds
    [] nt0
        ("································"
         "································"
         "································"
         "······.··*······················"
         "································"
         "······TAPS······················"
         "································"
         "································"
         "································"
         "·⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐·"
         "·⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐⊏⊐·"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································"
         "································")
ct U[64] attr1 = U[64](
    $00, $00, $00, $00, $00, $00, $00, $00, 
    $00, $00, $00, $00, $00, $00, $00, $00, 
    $55, $55, $55, $55, $55, $55, $55, $55, 
    $00, $00, $00, $00, $00, $00, $00, $00, 
    $00, $00, $00, $00, $00, $00, $00, $00, 
    $00, $00, $00, $00, $00, $00, $00, $00, 
    $00, $00, $00, $00, $00, $00, $00, $00, 
    $00, $00, $00, $00, $00, $00, $00, $00, 
)
fn load_bg()
    // Tell the NES which VRAM address we want to upload to:
    ppu_reset_addr($2000)

    // tiles for first nametable
    for UU i = 0; i < 960; i += 1
        {PPUDATA}(@nt0{i})

    // attributes for first nametable
    for U i = 0; i < 64; i += 1
        {PPUDATA}(attr1[i])

    // tiles for second nametable
    for UU i = 0; i < 960; i += 1
        {PPUDATA}(0)

    // attributes for second nametable
    for U i = 0; i < 64; i += 1
        {PPUDATA}(%00000000)

fn prepare_sprites()
    U oam_index = 0
    if recording
        set_oam(oam_index, 12, 19, RECORD_SPRITE, %11)
        oam_index += 4
    // write hz sprites
    if hz_digits[4] != 0
        set_oam(oam_index, 24, 23, hz_digits[3], %00)
        oam_index += 4
    set_oam(oam_index, 32, 23, hz_digits[3], %00)
    oam_index += 4
    set_oam(oam_index, 40, 23, hz_digits[2], %00)
    oam_index += 4
    set_oam(oam_index, 56, 23, hz_digits[1], %00)
    oam_index += 4
    set_oam(oam_index, 64, 23, hz_digits[0], %00)
    oam_index += 4
    // write tap count sprite
    set_oam(oam_index, 32, 39, tap_count, %11)
    oam_index += 4
    // TODO: write probability sprites
    hide_oam(oam_index)

fn clear_vars_after_cooldown()
    polls_this_frame[0] = 0
    polls_this_frame[1] = 0
    num_frames_recording = 0
    prev_poll_on = false
    prev_nmi_poll_on = false
    last_tap_count = 1

fn update_polls_this_frame()
    U i = subframe_index >> 3
    polls_this_frame[i] |= @powers_of_two[subframe_index & %111]

fn handle_poll()
    fence
    Bool is_button_pressed = pads[0].held & (BUTTON_LEFT | BUTTON_RIGHT)
    if is_button_pressed
        cooldown = COOLDOWN_THRESHOLD
        if !recording
            // special logic if recording begins with the nmi poll
            // done so the first poll which would be recognized by the
            // actual game lines up in all cases
            if subframe_index == 0
                num_frames_recording = 1
            recording = true
            tap_count = 0
            start_index = (num_frames_recording << 4) + UU(subframe_index)
            end_index = start_index
            shift_nt1()
        fence
        update_polls_this_frame()
        if !prev_poll_on
            tap_count += 1
            end_index = (num_frames_recording << 4) + UU(subframe_index)
    fence
    // TODO: can be moved when buffer is refactored
    if subframe_index == 0 
        if !prev_nmi_poll_on && is_button_pressed
            play_sfx = true
        prev_nmi_poll_on = is_button_pressed
    prev_poll_on = is_button_pressed


fn shift_nt1()
    // scroll up to push existing entries down
    roll_viz_addr -= $20 * ROW_HEIGHT
    if roll_viz_addr < $2400
        roll_viz_addr += $3C0
    if roll_viz_y < (ROW_HEIGHT << 3)
        roll_viz_y += ($F0 - (ROW_HEIGHT << 3)) // mod 240
    else
        roll_viz_y -= (ROW_HEIGHT << 3)

fn swap_chr_bank(U register, U bank)
: +inline
    fence
    {MMC3_BANK_SELECT}(%00000000 | (register << 7))
    {MMC3_BANK_DATA}(bank << 2)
    {MMC3_BANK_SELECT}(%00000001 | (register << 7))
    {MMC3_BANK_DATA}((bank << 2) + 2)
    fence

asm fn wait_for_last_poll()
: employs /hz
    default
    label loop
        lda &subframe_index
        cmp #$10
        bne loop
        rts

// for scroll, hopefully does not matter
irq subframe_poll()
    // acknowledge pending irq, then immediately schedule next irq (but not now)
    // already disables so this is safe
    mmc3_timer(@scanline_intervals[subframe_index])
    // set scroll/change chr bank at specific index
    if subframe_index == 7
        fence
        waste_time += 1
        fence
        ppu_set_mid_scroll(0, roll_viz_y, 1)
        swap_chr_bank(0, 2)
    // poll controller (TODO: waste cycles for more accuracy??)
    poll_pads()
    update_pads()
    fence
    // if recording and L/R pressed, update active buffer with next tile
    handle_poll()
    subframe_index += 1

nmi main_nmi()
: employs /ppu
    // schedule irq for showing nt1
    mmc3_timer(@scanline_intervals[0])
    // make background bank normal
    swap_chr_bank(0, 0)
    // set sprite palettes
    ppu_reset_addr($3F11)
    {PPUDATA}(main_hz_color)
    // Update OAM and poll the pads (currently scanline 246, cycle 90)
    ppu_upload_oam_poll_pads(0)
    update_pads()
    fence
    if recording
        if num_frames_recording < UU(NUM_VISIBLE_FRAMES)
            // update frame row (2 tiles)
            U i = num_frames_recording.a << 1
            // the first frame will never show up on the rame row, so this is
            // fine
            if i == 2
                // +2 is again because first frame always empty
                ppu_reset_addr(FRAME_ROW_ADDR + 2)
                // TODO: MAGIC NUMBER
                for U j = 0; j < 14; j += 1
                    {PPUDATA}('⊏')
                    {PPUDATA}('⊐')
                // two tiles of nothing
                {PPUDATA}('·')
                {PPUDATA}('·')
                for U j = 0; j < 15; j += 1
                    {PPUDATA}('⊏')
                    {PPUDATA}('⊐')
            UU poll_addr = roll_viz_addr + UU(1 + i)
            UU frame_row_addr = FRAME_ROW_ADDR + UU(i)
            if i >= NUM_VISIBLE_FRAMES
                poll_addr += 2
                frame_row_addr += 2
            ppu_reset_addr(poll_addr)
            {PPUDATA}(polls_this_frame[0])
            {PPUDATA}(polls_this_frame[1])
            // update frame row if needed
            ppu_reset_addr(frame_row_addr)
            if polls_this_frame[0] & $01 != 0
                {PPUDATA}('⊑')
                {PPUDATA}('⊒')
            polls_this_frame[0] = 0
            polls_this_frame[1] = 0

        num_frames_recording += 1
    else if clear_offscreen
        // clear all in the topmost invisible buffer
        // TODO: tune if necessary
        UU clear_addr = roll_viz_addr - UU($20 * ROW_HEIGHT)
        if clear_addr < $2400
            clear_addr += $3C0
        fence
        ppu_reset_addr(clear_addr)
        for U i = 0; i < 63; i += 1
            {PPUDATA}(0)
        fence
        clear_offscreen = false
    // TEST: seems to add 5 scanlines
    // for U i = 0; i < 4; i += 1
    //     ppu_reset_addr($206D + UU($20 * i))
    //     for U j = 0; j < 16; j += 1
    //         {PPUDATA}('·')

    // "irq 0"
    subframe_index = 0
    fence
    handle_poll()
    fence
    subframe_index = 1 // MUST HAPPEN BEFORE END OF VBLANK
    // set scroll to show current roll viz row
    ppu_reset_mid_scroll(0, 0, 0)

mode main()
: nmi main_nmi
: irq subframe_poll
    // set the palette:
    palette = START_PALETTE
    ppu_upload_palette()

    // set and load the level:
    hide_oam(0)
    load_bg()
    clear_vars_after_cooldown()

    //set mirroring
    {MMC3_MIRRORING}(0)


    // enable nmi, turn on rendering
    {PPUCTRL}(PPUCTRL_NMI_ON | PPUCTRL_SPR_PT_1000)
    nmi
    {PPUMASK}(PPUMASK_ON | PPUMASK_NO_CLIP)

    // enable irqs
    irq true

    // Wait forever, one frame at a time:
    while true
        if last_recording
            // use `last_` variables for all of these
            // update hz measurement(s)
            if last_tap_count > 1 && last_tap_count != $FF
                // should always fit
                UUU hz_dividend = (NTSC_FRAMERATE * (last_tap_count - 1)) << 3
                UU interval = last_end_index - start_index
                fence
                hz = UU(udiv_24(hz_dividend, interval) << 1)
                // TODO: this can probably go above 100
                hz_digits = U[5](uu_to_ddddd(UU(hz)))
            // update probability buffers???
        else if pads[0].pressed & BUTTON_START
            // change mode here
            stat_mode += 1
            if stat_mode == NUM_STAT_MODES
                stat_mode = 0
            // schedule previous mode cleanup, new mode init
        else if pads[0].pressed & BUTTON_SELECT
            // reset mode
        prepare_sprites()
        // probably ok here since we're only checking polls at nmi (for now)
        update_audio()
        // wait for all polls to finish up
        fence
        wait_for_last_poll()
        fence
        // middle byte of hz for color
        // in order for this to not be bugged it has to be here????????
        main_hz_color = @hz_gradient[hz.b]
        if last_recording
            if cooldown == 0
                recording = false
                last_recording = false
                clear_vars_after_cooldown()
                clear_offscreen = true
            else
                cooldown -= 1
                last_tap_count = tap_count
                last_end_index = end_index
        last_recording = recording
        nmi

chrrom
    file(fmt, "../chr/hud.png")
    file(fmt, "../chr/hud.png")
    file(fmt, "../chr/hz.png")
    file(fmt, "../chr/hz.png")
